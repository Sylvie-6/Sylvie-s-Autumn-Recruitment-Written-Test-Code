新的一个季度又要到了，多多君准备在多多路上再种一些树木。\
多多路上已经有了N棵树木（编号1~N），对于每一棵树，多多君都给打了一个美观值评分，其中第i棵树的美观值记为A_i。 \
而对于多多路上的每个区间，其整体的美观值可以认为是该区间中每棵树的美观值之和。\
多多君不太喜欢数字M，所以当某个区间的美观值为M时，就需要在该区间中再种若干树木，使得没有任何一个区间的美观值为M。 \
多多君想知道，假设新种的树木的美观值可以任意挑选的情况下，最少需要再种多少棵树，可以满足上述要求。\
输入描述共两行，第一行，两个整数N和M，分别表示当前已有树木的数量和多多君不喜欢的数字M。 （1 <= N <= 100000 ；-1,000,000 <= M <= 1,000,000 ） \
第二行，N个整数A_i，第i个整数表示第i棵树木的美观值。 （-1,000,000 <= A_i <= 1,000,000 且保证A_i不等于M ）\
输出描述共一行，一个整数，表示最少需要再种多少树，可以满足没有任意一个区间的美观值为M的要求。\
示例1：\
输入：4 -1\
3 -3 2 3\
输出：1\
解释：只有一个区间[2, 3]的美观值为-3 + 2 = -1不符合要求。\
可以选择在[2, 3]之间再种一颗美观值为1的树，使得整体为3 -3 1 2 3，如此没有任何一个区间的美观值为-1。\
示例2：\
输入：5 100\
1 2 3 4 5\
输出：0\
解释：没有一个区间的和谐之和为100。\
示例3：\
输入：9 0\
-1 1 -1 1 -1 1 1 -1 -1\
输出：6\

---
与代码用前缀和与集合维护当前段的历史和；一旦出现禁值子段，则立即在当前位置前切分并重置集合，同时计数；线性扫描结束即得最少切分次数。
---

```cpp

