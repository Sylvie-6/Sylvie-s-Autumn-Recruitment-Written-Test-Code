多多最近迷上了一款闯关游戏，游戏中有N个依次排列的关卡，每个关卡都有两个属性：通关奖励：完成这个关卡能获得多少积分挑战难度：\
这个关卡有多难通过，用一个正整数表示 现在多多想要选择一段连续的关卡来挑战（比如第3关到第7关），这段关卡需要满足：\
这些关卡的总积分奖励至少要达到目标分数T；在满足积分要求的前提下，选中的关卡中最大的难度值要尽可能小\
请找出满足条件的一段连续关卡，输出这段关卡的最高难度\
题目保证必定有解输入描述第一行两个整数N（1≤N≤100000）和T（1≤T≤1e18），分别表示关卡的数目和目标分数 \
接下来N行，每行两个整数Si（1≤Si≤1e18）和Di（1≤Di≤1e9），分别表示第i个关卡的得分和难度输出描述一个整数表示答案
示例1：\
输入：\
5 10\
4 10\
6 15\
3 5\
4 9\
3 6\
输出：9\
解释：选择关卡3-5，总得分3+4+3 >= 目标分数10，难度为9；其他满足总得分>=10的关卡，最高难度都大于9

---
对目标答案做二分检索；给定阈值时，只在不超过阈值的连续段内累加积分，若某一段达到目标即判为可行；可行则收缩，否则放宽；最终得到最小可行阈值。
---
```cpp
#include<deque>
#include<iostream>
#include<vector>
using namespace std;

class Solution{
  int Difficulty(int N, int T, vector<long long>& S, vector<int>& D){
    long long sum = 0;
    int l = 0;//滑动窗口左端点
    deque<int> dq;//存索引，维护区间难度的最大值，单调递减
    for(int r = 0; r < N; r++){
      sum += S[r];

      while(!dq.empty() && D[dq.back()] <= D[r]) dq.pop_back();
      dq.push_back(r);

      while(sum - S[l] >=T){
        sum -= S[l];
        if(!dq.empty() && dq.front() == l) dq.pop_front();
        l++;
      }

      if(sum > T){
        ans = min (ans, D[dq.front()]);
      }

  }

};



int main(){
  int N;
  long long T;
  cin >> N >> T;

  vector<long long> S(N);
  vector<int> D(N);
  for(int i = 0; i < N; i++){
    cin >> S(i) >> D(i);
  }

  int ans = INT_MAX;
  Solution s;
  ans = s.Difficulty(N, T, S(N), D(N));

  cout << ans << endl;
  return 0;
}

  
