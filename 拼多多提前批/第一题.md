题意：多多正在参加一个特殊的满减活动，有n个各不相同的商品，每个商品的价格是a_i。活动规则是——若挑选的两个商品的价格总和是m的倍数的话，可以免费带走这两个商品。\
由于多多最多只能带两个商品，请问多多有多少种组合方式免费带两个商品。\
输入描述第一行输入两个数字n和m。 接下来输入n个商品的价格a_i，a_i为整数。 \
1 ≤ n ≤ 200000，1 ≤ m < 200000，1 ≤ a_i ≤ 1000000000输出描述输出一个数字，表示多多能免费带走两个商品的方式数量。\
最终结果对998244353取模 

示例1：\
输入：\
2 4  \
1 3  
输出：1  
解释： 多多只有1种方式免费拿走两件商品。第1件商品和第2件商品  
示例2：\
输入：\
5 2  \
1 2 3 4 5  
输出：4  
解释： 多多只有1种方式免费拿走两件商品。第1件商品和第2件商品  

---
先把所有价格按给定数取模做频次统计；把余数为零的内部两两配对计入；对每个正余数只与它的补余配对；若给定数为偶数，再额外计算一半位置的内部配对；结果取指定模数。
---

```cpp
#include <bitss/stdc++.h>
using namespace std;

const long long MOD = 998244353;

class Solution{
public:
            int take(int n, int m, vector<int>& prices){
                        vector<long long> cnt(m, 0);
                        for(long long i = 0; i < n; ++i){
                                    long long r = ((prices[i] % m) + m) % m;//兼容负数的情况，确保最终得到的余数 r 一定是 [0, m-1] 之间的非负整数
                                    cnt[r]++;
                        }

                        long long ans = 0;
                        auto C2 = [&](long long x) -> long long{
                                    if(x < 2) return 0;
                                    int t = x * (x - 1) / 2;
                                    return (long long)(t % MOD);
                        };
                        //r=0
                        ans = (ans + C2(cnt[0])) % MOD;
                        //r与m-r
                        for(long long r =1; r * 2 < m; ++r){
                                    int ways = cnt[r] * cnt[m-r];
                                    ans = (ans + (long long)(ways % MOD)) %MOD;
                        }
                        //r-m/2
                        if(m % 2 == 0) ans = (ans + C2(cnt[m / 2]) % MOD;
                        return ans;
            }
};

int main(){
            long long n ,m;
            if((!cin >> n >> m)) return 0;
            vector<int> prices(n, 0);
            for(int i = 0; i < n; ++i){
                        cin >> prices[i];
            }
            Solution s;
            int ans = s.take(n, m, prices);
            cout << ans % MOD << endl;
            return 0;
}

'''



