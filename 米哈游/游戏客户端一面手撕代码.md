# 八股
* 继承、菱形继承、
* 虚函数、虚函数表、抽象类（纯虚函数）、抽象类是否可以实例化（不可以）、有没有了解过接口（C++中一个只包含纯虚函数的抽象类=接口）
* 析构函数是否可以是虚函数、虚析构和普通析构的应用场景是什么（普通类不会被继承/明确不需要多态删除->析构，任何可能被继承的基类->虚析构）
* 智能指针有什么、分别作用是什么
* set查询速度（O(logn)）、底层是什么、为什么红黑树能实现查询是O(logn)、unordered_set的底层和查询速度、哈希冲突怎么解决
* 说说内存中的堆和栈的区别、堆和栈上创建对象哪个更快、堆和栈哪个访问速度更快（栈，因为栈是连续自动管理的）
* 进程是什么、线程是什么、进程运行的时候系统会给它分配什么资源、线程怎么解决竞态、线程锁在一个什么比较大的概念下（应该是问的线程同步？）、除了互斥锁之外还有什么方法能解决线程冲突
* 有没有了解过垃圾回收机制、在C++中以什么样的数据结构来表示多个对象之间相互引用（有向图，程序内存结构可以抽象成有向图）、所以垃圾一般是什么样的节点（有向图中遍历不可达的点）
* TCP和UDP、为什么TCP要三次握手、两次不行吗

# 判断有向图中是否有环

面试时候考虑到的是dfs+数组记录已经访问过的节点

### 三状态法经典判断有无环


---
```cpp
#include<vector>
#include<iostream>
using namespace std;

class Solution{
private:
  bool dfs(const vector<vector<int>>>& graph, int u, vector<int>& visited){
    visited[u] = 1;//正在访问该节点
    for(int g : graph[u]){
      if(visited[g] == 0){
        if(dfs(graph, g, visited)){
          return true;
        }
      }else if(visited[g] == 1) return true;
    }
    visited[u] = 2;
    return false;
  }
public:
  bool hasCycle(vector<vector<int>>& graph){
    int n = graph.size();
    vector<int> visited(n, 0);//没访问过：0，访问中：1，已访问：2
    for(int i = 0; i < n; i++){
      if(visited[i]==0){
        if(dfs(graph, i, visited)) return true;
      }
    }
    return false;
  }
};


int main() {
    Solution sol;
    vector<vector<int>> graph = {
        {1},     // 0 -> 1
        {2},     // 1 -> 2
        {0}      // 2 -> 0 
    };

    cout << (sol.hasCycle(graph) ? "有环" : "无环") << endl; 
    return 0;
}
