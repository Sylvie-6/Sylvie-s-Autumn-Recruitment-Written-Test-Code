米小游和 Zeeman 又在玩游戏了。\
他们面前有n堆石子，其中第i堆有ai个石子。两人需要轮流从这些石子里面取，由米小游先行。\
*轮到某个玩家取石子时，必须满足以下规则：首先，玩家选择一个下标i，且ai>1；\
*接下来，玩家需要选择一个正整数d满足d<ai且ai mod d=0 换句话说，找到一个比ai小且能整除ai的正整数d，并从第i堆里取走d石子。\
如果没有满足条件的d，则不可以选择这一堆。如果轮到某个玩家时，他无法取走任何石子，则另一个玩家胜利。\
如果 米小游 和 Zeeman 都采取最佳策略，请你判断游戏的胜者。\
### 输入描述
每个测试文件均包含多组测试数据。\
第一行输入一个整数T代表数据组数，每组测试数据描还如下：第一行输入一个整数n，表示石子的堆数。\
第二行输入n个整数a1,...,an，代表每堆石子的数量。除此之外，保证单个测试文件的n之和不超过2×10^5。\

### 输出描述
对于每组测运效据，输出一行一个字符串：如果米小游是胜者，则输出Baobao，否则输出Zeeman。

样例1\
输入\
5\
2\
4 4\
1\
2\
2\
114514 1919810\
5\
16 48 22 12 24\
2\
4 2

输出\
Zeeman\
Baobao\
Zeeman\
Zeeman\
Baobao\
说明\
在最后一组测试数据中，米小游先手可以选择i=1和d=2，即从第一堆中取走2个石子，当前石子状态变为 {2,2} 。\
这时，无论 Zeeman 选择哪一堆，他都只能取走该堆中的1个石子。米小游只需要从另一堆中也取走1个石子将石子状态变为 {1,1} 。\
这时 Zeeman 无法取走任何石子，米小游获胜。

---
## Nim 博弈
实际上，这题等价于一个 Nim 博弈，每堆石子的“贡献”不是 a[i] 本身，而是它里面包含的 2 的幂次。\
对于一个数 a[i]，设 𝑔=它含有的因子 2 的个数 （即 a[i] 可以写成 2^g * k，其中 k 是奇数）。\
游戏等价于：每堆石子就是一堆「大小为 g 的石子」在 Nim 游戏里的堆。\
最终胜负 = 所有 g 的 异或和（或模 2）来决定。
* 只要你从奇数出发，下一步一定会变成偶数。而偶数才有「更丰富的可拆性」；奇数本身不能无限拆，最后一定会被走到一个 质数（比如 3、5、7），这时候就不能动了（因为唯一真因子是 1，取完剩 ai-1，继续下去就会变偶数）。
* 「奇数部分 k」并不会影响能走几步，因为奇数只能让你最终停下来（没有新的 2 可以继续拆）。真正决定「能玩几步」的是这个数里包含多少个因子 2，也就是 g。
* 为什么奇偶性决定先手胜负？
  * 「石子堆游戏」：每堆有 g 个石子，每次操作就是拿走 1 个。
  * 结论很简单：如果总石子数是 奇数，先手一定赢（因为轮到后手时总数必然变成偶数，最后一步必然由先手拿走）。如果总石子数是 偶数，先手必败（因为先手一动，总数变奇数，后手再动变偶数，最后一步必然由后手拿走）。

```cpp
#include<iostream>
#include<vector>

using namespace std;

int main() {
	int n, T;
	cin >> T;
	while (T--) {
		cin >> n;
		vector<long long> a(n, 0);
		for (int i = 0; i < n; ++i) {
			cin >> a[i];
		}
		long long sum = 0;
		for (int i = 0; i < n; ++i) {
			int g = 0;
			while(a[i] % 2 == 0) {
				++g;
				a[i] >>= 1; //a[i]=a[i]/2;
			}
			sum = (sum + g) % 2;
		}
		cout << (sum ? "Baobao" : "Zeeman") << endl;
	}
	return 0;
}
