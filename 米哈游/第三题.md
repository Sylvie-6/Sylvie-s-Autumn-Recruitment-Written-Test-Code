给定正整数n，以及k个可用的前缀旋转操作：\
第i个操作将字符串的前xi个字符移动到末尾。你可以对字符串执行任意次操作(可重复使用相同的xi) 。\
对于目标偏移y(0<=y<n)，定义目标结果为循环左移y位(即将前y个字符移至末尾)的字符串。\
现在需要回答m个查询：对于每个查询给定的偏移yi，求使用前缀旋转操作，达成目标偏移yi所需的最少操作次数;若无法达到，则输出-1。\

【名词解释】前缀旋转：前缀旋转指将字符串s的前x个字符移动到末尾，例如将 "abcde" 的前2个字符旋转后得到"cdeab" 。
## 输入描述
第一行输入三个整数，n,k,m(1<=n<=5×10^4;1<=k<=100;1<=m<=10^5)分别表示字符串长度、可用操作数和查询次数；\
第二行输入k个整数x1,...,xk，表示可用的前缀旋转长度,1<=xi<=n；
第三行输入m个整数y1,...,ym，表示目标偏移,0<=xi<n。

## 输出描述
对于每个查询yi，按输入顺序，新起一行输出一个整数，表示使s循环左移yi位(即将前yi个字符移动至末尾)所需的最少前缀旋转操作次数；若不可达，则输出-1。

样例1\
输入\
5 2 3\
1 3\
0 1 4\
输出\
0\
1\
2\
说明在这个样例中：偏移0 ：无需操作；偏移1：使用x1=1一次；偏移4：先使用x2=3，再使用x1=1，共2次。

样例2\
输入\
6 2 4\
3 6\
0 3 1 4\
输出\
0\
1\
-1\
-1\
说明在此样例中，只有偏移0和3可达。

---
## 广度优先搜索（BFS）
设 y_i 为目标偏移，那么我们想找到一种方式，使得通过多个操作 x_1, x_2, ..., x_k 的组合，最终得到 y_i 的值。\
这个问题可以转化为一个最短路径问题，寻找通过多个 x_i 组合得到 y_i 的最小操作次数。\
建图和最短路径： 将每个偏移量看成一个节点，边表示通过一个操作能从某个偏移量转移到另一个偏移量。\
问题转化为从起始位置（偏移量 0）出发，最短路径到达目标偏移量 y_i。

## 辗转相除法
题目还可以看成，在长度为n的环上，从位置0出发，每次可以走x步，能不能走到y，如果能，最少走几步？
如果可达的话，可达的位置应该是所有x和n的最大公约数g的倍数。所以看y能否被g整除，就可以判断可不可达。
再用BFS找最短路径。

---
```cpp
#include<iostream>
#include<vector>
#include<unordered_set>
#include<queue>

using namespace std;

//直接用BFS
int main() {
	long long n, m;
	int k;
	cin >> n >> k >> m;
	vector<int> X(k, 0);
	vector<int> Y(m, 0);
	for (int i = 0; i < k; i++) cin >> X[i];
	for (int i = 0; i < m; i++)  cin >> Y[i];

	vector<int> dist(n, -1);
	dist[0] = 0;//初始状态不旋转为0
	queue<int> que;
	que.push(0);
	while (!que.empty()) {
		int cur = que.front();
		que.pop();
		for (int i = 0; i < k; ++i) {
			int temp = (cur + X[i]) % n;
			if (dist[temp] == -1) {
				dist[temp] = dist[cur] + 1;
				que.push(temp);
			}
		}
	}
	for (int i = 0; i < m; ++i) {
		cout << dist[Y[i]] << endl;
	}
	return 0;
}


```cpp
#include<iostream>
#include<vector>
#include<unordered_set>
#include<queue>

//辗转相除法

long long gcd(long long a, long long b) {
	while (b != 0) {
		long long t = a % b;
		a = b;
		b = t;
	}
	return a;
}


int main() {
	long long n, m;
	int k;
	cin >> n >> k >> m;
	vector<int> X(k, 0);
	vector<int> Y(m, 0);
	for (int i = 0; i < k; i++) cin >> X[i];
	for (int i; i < m; i++)  cin >> Y[i];

	long long g = n;

	vector<int> steps;
	steps.reserve(k);

	unordered_set<int> seen;
	for (long long x : X) {
		int t = x % n;
		if (t == 0) continue;//去掉重复的步长
		if (seen.insert(t).second) {//seen.insert(t)的返回值是pair<iterator, bool>
			steps.push_back(t);
			g = gcd(g, (long long) t);
		}
		//seen / seen2 就是哈希集合，用来判重。
	}
	//没有有效步长，只有y=0可达
	if (steps.empty()) {
		for (int i = 0; i < m; i++) {
			cout << (Y[i] % n == 0 ? 0 : -1) << endl;
		}
		return 0;
	}

	//判断可达性
	vector<int> ans(m, -1);
	vector<int> idxNeed(m, 0);
	for (int i = 0; i < m; i++) {
		if (Y[i] % g == 0) idxNeed.push_back(i);//可达的放进 idxNeed，后面 BFS 求最小步数。
		else ans[i] = -1;
	}

	if (!idxNeed.empty()) {
		//压缩空间：因为所有状态都落在 g 的倍数上，可以把问题缩小到 n2 = n/g
		int n2 = n / g;
		//step2 是压缩后的步长集合。
		vector<int> step2(steps.size(),0);

		unordered_set<int> seen2;
		for (int t : steps) {
			int v = (t / g) % n2;
			if (v == 0) continue;
			if (seen2.insert(v).second) step2.push_back(v);
		}

		//在模 n2 的环上做 BFS。
		vector<int> dist(n2, 1e9); 
		queue<int> q;
		dist[0] = 0;//dist[i] 表示从 0 到 i 的最少操作数。
		q.push(0);

		while (!q.empty()) {
			int u = q.front();//u：当前节点（当前位置，对应一个模 n2 的余数）。
			q.pop();
			for (int d : step2) {//d：一个步长（压缩后的 step2 里的元素）。
				int v = u + d;//从位置 u 出发，走一步步长 d，会到达下一个位置 v。
				if (v >= n2) v -= n2;//等价于 v = (u + d) % n2
				if (dist[v] == 1e9) {//BFS 的性质：第一次到达某点就是最短路，所以只在“未访问”时更新它。
					dist[v] = dist[u] + 1;//由 u 走一步到 v，步数是 dist[u] + 1
					q.push(v);
				}
			}
		}

		for (int i : idxNeed) {
			int y2 = (Y[i] / g) % n2;
			ans[i] = (dist[y2] == 1e9 ? -1 : dist[y2]);
		}
	}

	for (int i = 0; i < m; i++) {
		cout << ans[i] << endl;
	}
	return 0;
}

