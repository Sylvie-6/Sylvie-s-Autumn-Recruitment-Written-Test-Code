多多先生经营着一个生机勃勃的多多果园。果园里不仅种满了各种果树，还吸引了许许多多可爱的小动物前来定居。\
最近，果园的收获季到了，多多先生收获了许多筐香甜的果实。在果园的一角，有一个存放备用果实的大仓库，仓库里有X筐果实。\
神奇的是，从第1天开始，每天早晨都会有一只新的小动物来到果园，希望能在这里定居。每只小动物的食量都不同。\
如果多多先生允许第i天来的小动物留下，那么这只小动物就会从“当天（第i天）”开始，一直到第n天结束，每天都需要吃掉c_i筐果实才能感到幸福。
多多先生非常善良，他希望果园里的小动物越多越好。但是，他也必须保证每一只留在果园的小动物，从它来到的那天起直到第n天，每一天都能吃到足够的食物，绝不能有任何一只小动物挨饿。\
多多先生可以选择拒绝任何一只前来定居的小动物。被拒绝的小动物会默默地离开，不会消耗果园的任何果实。\
请问，在第n天结束时，多多先生的果园里最多能有多少只幸福的小动物？

输入描述输入的第一行包含两个整数n和X（1≤n≤200000，1≤X≤10^18），分别表示果园收获季的总天数，以及初始时仓库里备用的果实筐数。 \
输入的第二行包含n个整数c_1, c_2, …, c_n（1≤c_i≤300），其中c_i表示第i天前来定居的小动物的每日食量。数字之间用空格隔开。\
输出描述输出一个整数，表示在第n天结束时，在保证所有小动物每天都能吃饱、一直幸福的前提下，果园里所能拥有的小动物的最大数量。\
示例1：\
输入：
3 8\
2 2 2\
输出：2\
示例2：
输入：\
3 12\
2 2 2\
输出：3

---
把每只对象的总消耗量等于到季末的天数乘以日需求，全部排序后从小到大贪心累加，直到超过总预算为止，累加数量即为答案。
---

'''cpp
#include <iostream>
#include <vector>
using namespace std;

class Solution{
  int happyAnimals(vector<long long>& c, long long x){
    int n = c.size();
    vector<long long> meed(n);
    for(int i = 0; i < n; i++){
      need[i] = c[i] * (long long)(n - i);
    }
    sort(need.begin(),need.end());

    long long sum = 0;
    int ans = 0;
    for(long long d : need){
      if(sum = d <= x){
        sum += d;
        ans++;
      }else break;
    }
    retrun ans;
  }
};

int mian(){
  int n;
  long long x;
  cin >> n >> x;
  vector<long long> c(n);
  for(int i = 0; i < n; i++){
    cin >> c[i];
  }

  Solution s;
  int ans = s.happyAnimals(c, x);
  cout << ans <<endl;
  return 0; 
}
